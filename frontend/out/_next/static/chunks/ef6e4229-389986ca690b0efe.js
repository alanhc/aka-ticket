"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[572],{2922:function(r,t,e){const n=Symbol("source_reference");class i extends Error{constructor(r,t,e){super(e),this.src=r,this.idx=t,Object.setPrototypeOf(this,i.prototype)}}var s;!function(r){r[r.Comment=0]="Comment",r[r.Number=1]="Number",r[r.String=2]="String",r[r.Bytes=3]="Bytes",r[r.Ident=4]="Ident"}(s||(s={}));const a=new RegExp("\\s"),o=new RegExp("[:@%_A-Za-z]"),c=new RegExp("[@%_\\.A-Za-z0-9]"),p=new RegExp("[0-9]"),l=new RegExp("[0-9a-fA-F]");function*u(r,t=!1){let e=0;for(;e<r.length;){for(;e<r.length&&a.test(r[e]);)e++;if(e===r.length)return;const n=r[e],u=e;if(o.test(n)){for(e++;e<r.length&&c.test(r[e]);)e++;yield{t:s.Ident,v:r.slice(u,e),first:u,last:e}}else if(r.length-e>1&&"0x"===r.substr(e,2)){for(e+=2;e<r.length&&l.test(r[e]);)e++;if(0!==(e-u&1))throw new i(r,e,"Bytes literal length is expected to be power of two");yield{t:s.Bytes,v:r.slice(u,e),first:u,last:e}}else if(p.test(n)||"-"===n){"-"===n&&e++;const t=e;for(;e<r.length&&p.test(r[e]);)e++;if(t===e)throw new i(r,e,"Number literal is too short");yield{t:s.Number,v:r.slice(u,e),first:u,last:e}}else if('"'===n){e++;let t=!1;for(;e<r.length&&(t||'"'!==r[e]);e++)t=!t&&"\\"===r[e];if(e===r.length)throw new i(r,e,"Unterminated string literal");e++,yield{t:s.String,v:r.slice(u,e),first:u,last:e}}else if("#"===n){for(e++;e<r.length&&"\n"!==r[e];)e++;t&&(yield{t:s.Comment,v:r.slice(u,e),first:u,last:e})}else if(r.length-e>1&&"/*"===r.substr(e,2)){for(e+=2;e<r.length&&!(r.length-e>1&&"*/"===r.substr(e,2));)e++;if(e===r.length)throw new i(r,e,"Unterminated C style comment");e+=2,t&&(yield{t:s.Comment,v:r.slice(u,e),first:u,last:e})}else{if("("!==n&&")"!==n&&"{"!==n&&"}"!==n&&";"!==n)throw new i(r,e,`Invalid character at offset ${e}: \`${n}'`);e++,yield{t:n,v:n,first:u,last:e}}}}const g=Symbol("ref_contract");var f;!function(r){r.Ps9mPmXa="Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P",r.PtCJ7pwo="PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY",r.PsYLVpVv="PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt",r.PsddFKi3="PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP",r.Pt24m4xi="Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd",r.PsBABY5H="PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU",r.PsBabyM1="PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS",r.PsCARTHA="PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb",r.PsDELPH1="PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo",r.PtEdoTez="PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq",r.PtEdo2Zk="PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA",r.PsFLoren="PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",r.PsFLorena="PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",r.PtGRANAD="PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",r.PtGRANADs="PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",r.PtHangzH="PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r",r.PtHangz2="PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx",r.PsiThaCa="PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP",r.Psithaca2="Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A",r.PtJakarta="PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw",r.PtJakart2="PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY",r.ProtoALpha="ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK"}(f||(f={}));const m=f.Psithaca2,h={Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P:0,PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY:1,PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt:2,PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP:3,Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd:4,PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU:5,PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS:5,PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb:6,PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo:7,PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq:8,PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA:8,PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i:9,PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV:10,PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r:11,PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx:11,PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP:12,Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A:12,PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw:13,PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY:13,ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK:14};function d(r,t){return h[r]<h[t]}class w extends Error{constructor(r,t){super(t),this.prim=r,Object.setPrototypeOf(this,w.prototype)}}function E(r,t){var e,n;if(0===t&&void 0===r.args||(null===(e=r.args)||void 0===e?void 0:e.length)===t)return!0;throw new w(r,`macro ${r.prim} expects ${t} arguments, was given ${null===(n=r.args)||void 0===n?void 0:n.length}`)}function b(r){if(void 0===r.annots)return!0;throw new w(r,`unexpected annotation on macro ${r.prim}: ${r.annots}`)}function v(r,t){if("int"in t)return!0;throw new w(r,`macro ${r.prim} expects int argument`)}function A(r,t,e,n){let i=0,s=0;const a=[null,null];let o;if(i===t.length)throw new w(r,`unexpected end: ${r.prim}`);let c,p=t[i++];switch(p){case"P":{const{r:a,n:c,an:p}=A(r,t.slice(i),e.slice(s),n);o=a,i+=c,s+=p;break}case"A":s!==e.length&&(a[0]=e[s++]);break;default:throw new w(r,`${r.prim}: unexpected character: ${p}`)}if(i===t.length)throw new w(r,`unexpected end: ${r.prim}`);switch(p=t[i++],p){case"P":{const{r:a,n:o,an:p}=A(r,t.slice(i),e.slice(s),n);c=a.map((([r,t])=>[r+1,t])),i+=o,s+=p;break}case"I":s!==e.length&&(a[1]=e[s++]);break;default:throw new w(r,`${r.prim}: unexpected character: ${p}`)}return{r:n(o,c,[0,a]),n:i,an:s}}function P(r,t,e,n){const i=t[0];switch(i){case"A":return t.length>1?[{prim:"DUP"},{prim:"DIP",args:[[{prim:"CAR",annots:["@%%"]},P(r,t.slice(1),[],n)]]},{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:["%@","%@",...e]}]:n.a;case"D":return t.length>1?[{prim:"DUP"},{prim:"DIP",args:[[{prim:"CDR",annots:["@%%"]},P(r,t.slice(1),[],n)]]},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@","%@",...e]}]:n.d;default:throw new w(r,`${r.prim}: unexpected character: ${i}`)}}function y(r,t){let e=r.length;for(;e>0&&r[e-1]===t;)e--;return r.slice(0,e)}function S(r){const t=[],e=[];if(void 0!==r)for(const n of r)(0!==n.length&&"%"===n[0]?t:e).push(n);return{fields:t,rest:e}}function T({prim:r,annots:t,args:e}){return Object.assign(Object.assign({prim:r},t&&{annots:t}),e&&{args:e})}const _=/^P[PAI]{3,}R$/,I=/^UNP[PAI]{2,}R$/,C=/^C[AD]{2,}R$/,O=/^SET_C[AD]+R$/,x=/^MAP_C[AD]+R$/,N=/^DI{2,}P$/,R=/^DU+P$/;class L extends Error{constructor(r,t){super(t),this.token=r,Object.setPrototypeOf(this,L.prototype)}}class D extends Error{constructor(r,t){super(t),this.node=r,Object.setPrototypeOf(this,D.prototype)}}const $=new L(null,"Unexpected EOF");function k(r){return r.t===s.Ident&&("@"===r.v[0]||"%"===r.v[0]||":"===r.v[0])}const U=new RegExp("^-?[0-9]+$"),F=new RegExp("^([0-9a-fA-F]{2})*$");class M{constructor(r){this.opt=r}expand(r){var t,e,i;if(void 0!==(null===(t=this.opt)||void 0===t?void 0:t.expandGlobalConstant)&&"constant"===r.prim){const t=function(r,t){return void 0!==r.args&&1===r.args.length&&"string"in r.args[0]&&r.args[0].string in t?t[r.args[0].string]:r}(r,this.opt.expandGlobalConstant);return t!==r&&(t[n]=Object.assign(Object.assign({},r[n]||{first:0,last:0}),{globalConstant:r})),t}if(void 0===(null===(e=this.opt)||void 0===e?void 0:e.expandMacros)||(null===(i=this.opt)||void 0===i?void 0:i.expandMacros)){const t=function(r,t){const e=(null===t||void 0===t?void 0:t.protocol)||m;function n(r){return void 0!==r?[{prim:"RENAME",annots:r}]:[]}switch(r.prim){case"CMPEQ":case"CMPNEQ":case"CMPLT":case"CMPGT":case"CMPLE":case"CMPGE":if(E(r,0))return[{prim:"COMPARE"},T({prim:r.prim.slice(3),annots:r.annots})];break;case"IFEQ":case"IFNEQ":case"IFLT":case"IFGT":case"IFLE":case"IFGE":if(E(r,2))return[{prim:r.prim.slice(2)},T({prim:"IF",annots:r.annots,args:r.args})];break;case"IFCMPEQ":case"IFCMPNEQ":case"IFCMPLT":case"IFCMPGT":case"IFCMPLE":case"IFCMPGE":if(E(r,2))return[{prim:"COMPARE"},{prim:r.prim.slice(5)},T({prim:"IF",annots:r.annots,args:r.args})];break;case"FAIL":if(E(r,0)&&b(r))return[{prim:"UNIT"},{prim:"FAILWITH"}];break;case"ASSERT":if(E(r,0)&&b(r))return[{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_EQ":case"ASSERT_NEQ":case"ASSERT_LT":case"ASSERT_GT":case"ASSERT_LE":case"ASSERT_GE":if(E(r,0)&&b(r))return[{prim:r.prim.slice(7)},{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_CMPEQ":case"ASSERT_CMPNEQ":case"ASSERT_CMPLT":case"ASSERT_CMPGT":case"ASSERT_CMPLE":case"ASSERT_CMPGE":if(E(r,0)&&b(r))return[[{prim:"COMPARE"},{prim:r.prim.slice(10)}],{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_NONE":if(E(r,0)&&b(r))return[{prim:"IF_NONE",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_SOME":if(E(r,0))return[{prim:"IF_NONE",args:[[[{prim:"UNIT"},{prim:"FAILWITH"}]],n(r.annots)]}];break;case"ASSERT_LEFT":if(E(r,0))return[{prim:"IF_LEFT",args:[n(r.annots),[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_RIGHT":if(E(r,0))return[{prim:"IF_LEFT",args:[[[{prim:"UNIT"},{prim:"FAILWITH"}]],n(r.annots)]}];break;case"IF_SOME":if(E(r,2))return[T({prim:"IF_NONE",annots:r.annots,args:[r.args[1],r.args[0]]})];break;case"IF_RIGHT":if(E(r,2))return[T({prim:"IF_LEFT",annots:r.annots,args:[r.args[1],r.args[0]]})];break;case"CAR":case"CDR":if(void 0===r.args)return r;if(E(r,1)&&v(r,r.args[0])){const t=parseInt(r.args[0].int,10);return T({prim:"GET",args:[{int:"CAR"===r.prim?String(2*t+1):String(2*t)}],annots:r.annots})}}if(_.test(r.prim)&&E(r,0)){const{fields:t,rest:e}=S(r.annots),{r:n}=A(r,r.prim.slice(1),t,((r,t,e)=>[...r||[],...t||[],e]));return n.map((([r,t],i)=>{const s=[...y(t,null).map((r=>null===r?"%":r)),...0===r&&i===n.length-1?e:[]],a=T({prim:"PAIR",annots:0!==s.length?s:void 0});return 0===r?a:{prim:"DIP",args:1===r?[[a]]:[{int:String(r)},[a]]}}))}if(I.test(r.prim)){if(d(e,f.PtEdo2Zk)&&E(r,0)){const{r:t}=A(r,r.prim.slice(3),r.annots||[],((r,t,e)=>[e,...t||[],...r||[]]));return t.map((([r,t])=>{const e=[{prim:"DUP"},T({prim:"CAR",annots:null!==t[0]?[t[0]]:void 0}),{prim:"DIP",args:[[T({prim:"CDR",annots:null!==t[1]?[t[1]]:void 0})]]}];return 0===r?e:{prim:"DIP",args:1===r?[[e]]:[{int:String(r)},[e]]}}))}if("UNPAIR"===r.prim)return r;if(E(r,0)){const{r:t}=A(r,r.prim.slice(3),[],((r,t,e)=>[e,...t||[],...r||[]]));return t.map((([r])=>{const t=T({prim:"UNPAIR"});return 0===r?t:{prim:"DIP",args:1===r?[[t]]:[{int:String(r)},[t]]}}))}}if(C.test(r.prim)&&E(r,0)){const t=[...r.prim.slice(1,r.prim.length-1)];return t.map(((e,n)=>{const i=n===t.length-1?r.annots:void 0;switch(e){case"A":return T({prim:"CAR",annots:i});case"D":return T({prim:"CDR",annots:i});default:throw new w(r,`unexpected character: ${e}`)}}))}if(O.test(r.prim)&&E(r,0)){const{fields:t,rest:e}=S(r.annots);if(t.length>1)throw new w(r,`unexpected annotation on macro ${r.prim}: ${t}`);const n=0!==t.length?{a:[{prim:"DUP"},{prim:"CAR",annots:t},{prim:"DROP"},{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:[t[0],"%@"]}],d:[{prim:"DUP"},{prim:"CDR",annots:t},{prim:"DROP"},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@",t[0]]}]}:{a:[{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:["%","%@"]}],d:[{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@","%"]}]};return P(r,r.prim.slice(5,r.prim.length-1),e,n)}if(x.test(r.prim)&&E(r,1)){const{fields:t}=S(r.annots);if(t.length>1)throw new w(r,`unexpected annotation on macro ${r.prim}: ${t}`);const e={a:[{prim:"DUP"},{prim:"CDR",annots:["@%%"]},{prim:"DIP",args:[[T({prim:"CAR",annots:0!==t.length?["@"+t[0].slice(1)]:void 0}),r.args[0]]]},{prim:"SWAP"},{prim:"PAIR",annots:[0!==t.length?t[0]:"%","%@"]}],d:[{prim:"DUP"},T({prim:"CDR",annots:0!==t.length?["@"+t[0].slice(1)]:void 0}),r.args[0],{prim:"SWAP"},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@",0!==t.length?t[0]:"%"]}]};return P(r,r.prim.slice(5,r.prim.length-1),[],e)}if(N.test(r.prim)&&E(r,1)){let t=0;for(;"I"===r.prim[1+t];)t++;return T({prim:"DIP",args:[{int:String(t)},r.args[0]]})}if(R.test(r.prim)){let t=0;for(;"U"===r.prim[1+t];)t++;if(d(e,f.PtEdo2Zk)){if(1===t){if(void 0===r.args)return r;E(r,1)&&v(r,r.args[0])&&(t=parseInt(r.args[0].int,10))}else E(r,0);return 1===t?[T({prim:"DUP",annots:r.annots})]:2===t?[{prim:"DIP",args:[[T({prim:"DUP",annots:r.annots})]]},{prim:"SWAP"}]:[{prim:"DIP",args:[{int:String(t-1)},[T({prim:"DUP",annots:r.annots})]]},{prim:"DIG",args:[{int:String(t)}]}]}if(1===t)return r;if(E(r,0))return T({prim:"DUP",args:[{int:String(t)}],annots:r.annots})}return r}(r,this.opt);return t!==r&&(t[n]=Object.assign(Object.assign({},r[n]||{first:0,last:0}),{macro:r})),t}return r}parseListExpr(r,t){var e;const i={first:t.first,last:t.last},a="("===t.t;let o;if(a){if(o=r.next(),o.done)throw $;i.last=o.value.last}else o={value:t};if(o.value.t!==s.Ident)throw new L(o.value,`not an identifier: ${o.value.v}`);const c={prim:o.value.v,[n]:i};for(;;){const t=r.next();if(t.done){if(a)throw $;break}if(")"===t.value.t){if(!a)throw new L(t.value,"unexpected closing bracket");i.last=t.value.last;break}if(k(t.value))c.annots=c.annots||[],c.annots.push(t.value.v),i.last=t.value.last;else{c.args=c.args||[];const s=this.parseExpr(r,t.value);i.last=(null===(e=s[n])||void 0===e?void 0:e.last)||i.last,c.args.push(s)}}return this.expand(c)}parseArgs(r,t){var e;const i={first:t.first,last:t.last},s={prim:t.v,[n]:i};for(;;){const t=r.next();if(t.done||"}"===t.value.t||";"===t.value.t)return[s,t];if(k(t.value))i.last=t.value.last,s.annots=s.annots||[],s.annots.push(t.value.v);else{const a=this.parseExpr(r,t.value);i.last=(null===(e=a[n])||void 0===e?void 0:e.last)||i.last,s.args=s.args||[],s.args.push(a)}}}parseSequenceExpr(r,t){var e,i;const a={first:t.first,last:t.last},o=[];o[n]=a;const c="{"===t.t;let p="{"===t.t?null:{value:t};for(;;){if(null===p&&(p=r.next(),p.done||(a.last=p.value.last)),p.done){if(c)throw $;return o}if("}"===p.value.t){if(c)return o;throw new L(p.value,"unexpected closing bracket")}if(p.value.t===s.Ident){const[t,i]=this.parseArgs(r,p.value);a.last=(null===(e=t[n])||void 0===e?void 0:e.last)||a.last,o.push(this.expand(t)),p=i}else{const t=this.parseExpr(r,p.value);a.last=(null===(i=t[n])||void 0===i?void 0:i.last)||a.last,o.push(t),p=null}null===p&&(p=r.next(),p.done||(a.last=p.value.last)),p.done||";"!==p.value.t||(p=null)}}parseExpr(r,t){switch(t.t){case s.Ident:return this.expand({prim:t.v,[n]:{first:t.first,last:t.last}});case s.Number:return{int:t.v,[n]:{first:t.first,last:t.last}};case s.String:return{string:JSON.parse(t.v),[n]:{first:t.first,last:t.last}};case s.Bytes:return{bytes:t.v.slice(2),[n]:{first:t.first,last:t.last}};case"{":return this.parseSequenceExpr(r,t);default:return this.parseListExpr(r,t)}}parseSequence(r){if("string"!==typeof r)throw new TypeError(`string type was expected, got ${typeof r} instead`);const t=u(r),e=t.next();return e.done?null:this.parseSequenceExpr(t,e.value)}parseList(r){if("string"!==typeof r)throw new TypeError(`string type was expected, got ${typeof r} instead`);const t=u(r),e=t.next();return e.done?null:this.parseListExpr(t,e.value)}parseMichelineExpression(r){if("string"!==typeof r)throw new TypeError(`string type was expected, got ${typeof r} instead`);const t=u(r),e=t.next();return e.done?null:this.parseExpr(t,e.value)}parseScript(r){return this.parseSequence(r)}parseData(r){return this.parseList(r)}parseJSON(r){if("object"!==typeof r)throw new TypeError(`object type was expected, got ${typeof r} instead`);if(Array.isArray(r)){const t=[];for(const e of r){if(null===e||"object"!==typeof e)throw new D(e,`unexpected sequence element: ${e}`);t.push(this.parseJSON(e))}return t}if("prim"in r){const t=r;if("string"===typeof t.prim&&(void 0===t.annots||Array.isArray(t.annots))&&(void 0===t.args||Array.isArray(t.args))){const r={prim:t.prim};if(void 0!==t.annots){for(const r of t.annots)if("string"!==typeof r)throw new D(r,`string expected: ${r}`);r.annots=t.annots}if(void 0!==t.args){r.args=[];for(const e of t.args){if(null===e||"object"!==typeof e)throw new D(e,`unexpected argument: ${e}`);r.args.push(this.parseJSON(e))}}return this.expand(r)}throw new D(r,`malformed prim expression: ${r}`)}if("string"in r){if("string"===typeof r.string)return{string:r.string};throw new D(r,`malformed string literal: ${r}`)}if("int"in r){if("string"===typeof r.int&&U.test(r.int))return{int:r.int};throw new D(r,`malformed int literal: ${r}`)}if("bytes"in r){if("string"===typeof r.bytes&&F.test(r.bytes))return{bytes:r.bytes};throw new D(r,`malformed bytes literal: ${r}`)}throw new D(r,`unexpected object: ${r}`)}}const K=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],H=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998];class G extends Error{constructor(r){super(r),this.message=r,this.name="Base58DecodingError"}}class j extends Error{constructor(r){super(r),this.message=r,this.name="InvalidMessageError"}}function Y(r){const t=(r.length+9)%64,e=0===t?0:64-t;if(r.length>268435455)throw new j(`SHA-256 -- message length is too big: ${r.length}`);const n=r.length<<3,i=[...r,128,...new Array(e).fill(0),0,0,0,0,n>>24&255,n>>16&255,n>>8&255,255&n];function s(r,t){return r>>>t|r<<32-t}const a=[...K],o=new Array(64),c=new Array(8);for(let l=0;l<i.length;l+=64){let r=l,t=0;for(;t<16;)o[t]=i[r]<<24|i[r+1]<<16|i[r+2]<<8|i[r+3],r+=4,t++;for(;t<64;){const r=s(o[t-15],7)^s(o[t-15],18)^o[t-15]>>>3,e=s(o[t-2],17)^s(o[t-2],19)^o[t-2]>>>10;o[t]=(0|e)+o[t-7]+r+o[t-16]|0,t++}for(let e=0;e<8;e++)c[e]=a[e];for(let e=0;e<64;e++){const r=s(c[0],2)^s(c[0],13)^s(c[0],22),t=s(c[4],6)^s(c[4],11)^s(c[4],25),n=c[7]+t+(c[4]&c[5]^~c[4]&c[6])+H[e]+o[e]|0,i=r+(c[0]&c[1]^c[0]&c[2]^c[1]&c[2])|0;c[7]=c[6],c[6]=c[5],c[5]=c[4],c[4]=c[3]+n|0,c[3]=c[2],c[2]=c[1],c[1]=c[0],c[0]=n+i|0}for(let e=0;e<8;e++)a[e]=a[e]+c[e]|0}const p=[];for(const l of a)p.push(l>>24&255),p.push(l>>16&255),p.push(l>>8&255),p.push(255&l);return p}const B=[0,1,2,3,4,5,6,7,8,-1,-1,-1,-1,-1,-1,-1,9,10,11,12,13,14,15,16,-1,17,18,19,20,21,-1,22,23,24,25,26,27,28,29,30,31,32,-1,-1,-1,-1,-1,-1,33,34,35,36,37,38,39,40,41,42,43,-1,44,45,46,47,48,49,50,51,52,53,54,55,56,57];function J(r,t){const e=r.charCodeAt(t)-49;if(e>=B.length||-1===B[e])throw new G(`Unexpected character at position ${t}: ${r[t]}`);return B[e]}function z(r){const t=function(r){const t=[];let e=0;for(;e<r.length&&0===J(r,e);)e++;let n=e;for(;e<r.length;){let n=J(r,e++),i=0;for(;0!==n||i<t.length;){const r=58*(t[i]||0)+n;t[i++]=r%256,n=Math.floor(r/256)}}for(;n-- >0;)t.push(0);return t.reverse()}(r);if(t.length<4)throw new G(`Data is too short ${t.length}`);const e=t.slice(0,t.length-4),n=t.slice(t.length-4),i=Y(Y(e));if(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==i[3])throw new G("Invalid checksum");return e}class V extends Error{constructor(r){super(r),this.message=r,this.name="InvalidContractError"}}class W extends Error{constructor(r){super(r),this.message=r,this.name="InvalidTypeExpressionError"}}class Q extends Error{constructor(r){super(r),this.message=r,this.name="InvalidDataExpressionError"}}class q extends Error{constructor(r){super(`Contract has no entrypoint named: '${r}'`),this.entrypoint=r,this.name="InvalidEntrypointError"}}Error;class Z extends Error{constructor(r){super(r),this.message=r,this.name="LongIntegerError"}}Error;class X extends Error{constructor(r,t){super(t),this.val=r,Object.setPrototypeOf(this,X.prototype)}}class rr extends X{constructor(r,t,e){super(r,e),void 0!==t&&(this.data=t),Object.setPrototypeOf(this,rr.prototype)}}class tr{constructor(r){if(this.neg=!1,this.buf=[],void 0!==r)if("string"===typeof r)for(let t=0;t<r.length;t++){const e=r.charCodeAt(t);if(0===t&&45===e)this.neg=!0;else{if(e<48||e>57)throw new Z(`unexpected character in integer constant: ${r[t]}`);this.append(e-48)}}else r<0?(this.neg=!0,this.append(-r)):this.append(r)}append(r){let t=0;for(;0!==r||t<this.buf.length;){const e=10*(this.buf[t]||0)+r;this.buf[t++]=e%256,r=Math.floor(e/256)}}cmp(r){if(this.neg!==r.neg)return(r.neg?1:0)-(this.neg?1:0);{let t=0;if(this.buf.length!==r.buf.length)t=this.buf.length<r.buf.length?-1:1;else if(0!==this.buf.length){let e=r.buf.length-1;for(;e>=0&&this.buf[e]===r.buf[e];)e--;t=e<0?0:this.buf[e]<r.buf[e]?-1:1}return this.neg?0===t?0:-t:t}}get sign(){return 0===this.buf.length?0:this.neg?-1:1}}function er(r){const t=[];for(let e=0;e<r.length;e+=2){const n=parseInt(r.slice(e,e+2),16);if(Number.isNaN(n))return null;t.push(n)}return t}function nr(r){try{return new tr(r),!0}catch(t){return!1}}function ir(r){try{return new tr(r).sign>=0}catch(t){return!1}}const sr=/^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;function ar(r,t){if(Array.isArray(r))return{};let e,n,i;if(void 0!==r.annots)for(const s of r.annots)if(0!==s.length){if(!sr.test(s)||!(null===t||void 0===t?void 0:t.specialVar)&&("@%"===s||"@%%"===s)||!(null===t||void 0===t?void 0:t.specialFields)&&"%@"===s)throw new X(r,`${r.prim}: unexpected annotation: ${s}`);switch(s[0]){case"%":((null===t||void 0===t?void 0:t.emptyFields)||s.length>1)&&(e=e||[],e.push(s));break;case":":s.length>1&&(n=n||[],n.push(s));break;case"@":((null===t||void 0===t?void 0:t.emptyVar)||s.length>1)&&(i=i||[],i.push(s))}}return{f:e,t:n,v:i}}const or={BlockHash:[32,[1,52]],OperationHash:[32,[5,116]],OperationListHash:[32,[133,233]],OperationListListHash:[32,[29,159,109]],ProtocolHash:[32,[2,170]],ContextHash:[32,[79,199]],ED25519PublicKeyHash:[20,[6,161,159]],SECP256K1PublicKeyHash:[20,[6,161,161]],P256PublicKeyHash:[20,[6,161,164]],ContractHash:[20,[2,90,121]],CryptoboxPublicKeyHash:[16,[153,103]],ED25519Seed:[32,[13,15,58,7]],ED25519PublicKey:[32,[13,15,37,217]],SECP256K1SecretKey:[32,[17,162,224,201]],P256SecretKey:[32,[16,81,238,189]],ED25519EncryptedSeed:[56,[7,90,60,179,41]],SECP256K1EncryptedSecretKey:[56,[9,237,241,174,150]],P256EncryptedSecretKey:[56,[9,48,57,115,171]],SECP256K1PublicKey:[33,[3,254,226,86]],P256PublicKey:[33,[3,178,139,127]],SECP256K1Scalar:[33,[38,248,136]],SECP256K1Element:[33,[5,92,0]],ED25519SecretKey:[64,[43,246,78,7]],ED25519Signature:[64,[9,245,205,134,18]],SECP256K1Signature:[64,[13,115,101,19,63]],P256Signature:[64,[54,240,44,52]],GenericSignature:[64,[4,130,43]],ChainID:[4,[87,82,0]],RollupAddress:[20,[1,128,120,31]],TxRollupL2Address:[20,[6,161,166]]};function cr(r,...t){const e=z(r);for(const n of t){const[r,t]=or[n];if(e.length===r+t.length){let r=0;for(;r<t.length&&e[r]===t[r];)r++;if(r===t.length)return[n,e.slice(t.length)]}}return null}function pr(r,t){const e=t,n=Array.isArray(e)?e:e.args;if(2===n.length){return"pair"===r?{prim:"pair",args:n}:{prim:"Pair",args:n}}return Object.assign(Object.assign({},Array.isArray(e)?{prim:r}:e),{args:[n[0],{prim:r,args:n.slice(1)}]})}function lr(r){return Array.isArray(r)||"pair"===r.prim}function ur(r){return Array.isArray(r)||"prim"in r&&"Pair"===r.prim}const gr=/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;function fr(r){if("string"in r){if(ir(r.string))return new Date(parseInt(r.string,10));if(gr.test(r.string)){const t=new Date(r.string);if(!Number.isNaN(t.valueOf))return t}}else if(nr(r.int))return new Date(parseInt(r.int,10));return null}const mr={ABS:!0,ADD:!0,ADDRESS:!0,AMOUNT:!0,AND:!0,APPLY:!0,BALANCE:!0,BLAKE2B:!0,CAR:!0,CDR:!0,CHAIN_ID:!0,CHECK_SIGNATURE:!0,COMPARE:!0,CONCAT:!0,CONS:!0,EDIV:!0,EQ:!0,EXEC:!0,FAILWITH:!0,GE:!0,GET_AND_UPDATE:!0,GT:!0,HASH_KEY:!0,IMPLICIT_ACCOUNT:!0,INT:!0,ISNAT:!0,JOIN_TICKETS:!0,KECCAK:!0,LE:!0,LEVEL:!0,LSL:!0,LSR:!0,LT:!0,MEM:!0,MUL:!0,NEG:!0,NEQ:!0,NEVER:!0,NOT:!0,NOW:!0,OR:!0,PACK:!0,PAIRING_CHECK:!0,READ_TICKET:!0,SAPLING_VERIFY_UPDATE:!0,SELF:!0,SELF_ADDRESS:!0,SENDER:!0,SET_DELEGATE:!0,SHA256:!0,SHA3:!0,SHA512:!0,SIZE:!0,SLICE:!0,SOME:!0,SOURCE:!0,SPLIT_TICKET:!0,SUB:!0,SWAP:!0,TICKET:!0,TOTAL_VOTING_POWER:!0,TRANSFER_TOKENS:!0,UNIT:!0,VOTING_POWER:!0,XOR:!0,RENAME:!0,OPEN_CHEST:!0,SUB_MUTEZ:!0,MIN_BLOCK_TIME:!0},hr=Object.assign({},mr,{CONTRACT:!0,CREATE_CONTRACT:!0,DIG:!0,DIP:!0,DROP:!0,DUG:!0,DUP:!0,EMPTY_BIG_MAP:!0,EMPTY_MAP:!0,EMPTY_SET:!0,GET:!0,IF:!0,IF_CONS:!0,IF_LEFT:!0,IF_NONE:!0,ITER:!0,LAMBDA:!0,LEFT:!0,LOOP:!0,LOOP_LEFT:!0,MAP:!0,NIL:!0,NONE:!0,PAIR:!0,PUSH:!0,RIGHT:!0,SAPLING_EMPTY_STATE:!0,UNPACK:!0,UNPAIR:!0,UPDATE:!0,CAST:!0,VIEW:!0}),dr={unit:!0,never:!0,bool:!0,int:!0,nat:!0,string:!0,chain_id:!0,bytes:!0,mutez:!0,key_hash:!0,key:!0,signature:!0,timestamp:!0,address:!0,tx_rollup_l2_address:!0},wr=Object.assign({},dr,{or:!0,pair:!0,set:!0,big_map:!0,contract:!0,lambda:!0,list:!0,map:!0,operation:!0,option:!0,bls12_381_g1:!0,bls12_381_g2:!0,bls12_381_fr:!0,sapling_transaction:!0,sapling_state:!0,ticket:!0,chest_key:!0,chest:!0});class Er extends X{constructor(r,t){super(r,t),this.val=r,Object.setPrototypeOf(this,Er.prototype)}}function br(r){return"prim"in r}function vr(r){if(br(r))return!0;throw new Er(r,"prim expression expected")}function Ar(r){if(Array.isArray(r))return!0;throw new Er(r,"sequence expression expected")}function Pr(r){if(function(r){return Array.isArray(r)||"prim"in r}(r))return!0;throw new Er(r,"prim or sequence expression expected")}function yr(r){if("-"===r.int[0])throw new Er(r,"natural number expected")}function Sr(r){if("int"in r)return!0;throw new Er(r,"int literal expected")}function Tr(r){if("string"in r)return!0;throw new Er(r,"string literal expected")}function _r(r,t){var e;if(0===t&&void 0===r.args||(null===(e=r.args)||void 0===e?void 0:e.length)===t)return!0;throw new Er(r,`${t} arguments expected`)}function Ir(r){var t,e;if(Array.isArray(r)){for(const t of r){if(!Array.isArray(t)&&!br(t))throw new Er(r,"sequence or prim expected");Ir(t)}return!0}if(vr(r)){if(Object.prototype.hasOwnProperty.call(mr,r.prim))return _r(r,0),!0;switch(r.prim){case"DROP":case"PAIR":case"UNPAIR":case"DUP":case"UPDATE":case"GET":void 0!==r.args&&_r(r,1)&&Sr(r.args[0])&&yr(r.args[0]);break;case"DIG":case"DUG":case"SAPLING_EMPTY_STATE":_r(r,1)&&Sr(r.args[0])&&yr(r.args[0]);break;case"NONE":case"LEFT":case"RIGHT":case"NIL":case"CAST":_r(r,1)&&kr(r.args[0]);break;case"UNPACK":_r(r,1)&&Or(r.args[0]);break;case"CONTRACT":_r(r,1)&&Rr(r.args[0]);break;case"IF_NONE":case"IF_LEFT":case"IF_CONS":case"IF":_r(r,2)&&(Ar(r.args[0])&&Ir(r.args[0]),Ar(r.args[1])&&Ir(r.args[1]));break;case"MAP":case"ITER":case"LOOP":case"LOOP_LEFT":_r(r,1)&&Ir(r.args[0]);break;case"CREATE_CONTRACT":_r(r,1)&&Mr(r.args[0]);break;case"DIP":if(2===(null===(t=r.args)||void 0===t?void 0:t.length))Sr(r.args[0])&&yr(r.args[0]),Ar(r.args[1])&&Ir(r.args[1]);else{if(1!==(null===(e=r.args)||void 0===e?void 0:e.length))throw new Er(r,"1 or 2 arguments expected");Ar(r.args[0])&&Ir(r.args[0])}break;case"PUSH":_r(r,2)&&(xr(r.args[0]),Fr(r.args[1]));break;case"EMPTY_SET":_r(r,1)&&Cr(r.args[0]);break;case"EMPTY_MAP":_r(r,2)&&(Cr(r.args[0]),kr(r.args[1]));break;case"EMPTY_BIG_MAP":_r(r,2)&&(Cr(r.args[0]),Lr(r.args[1]));break;case"LAMBDA":_r(r,3)&&(kr(r.args[0]),kr(r.args[1]),Ar(r.args[2])&&Ir(r.args[2]));break;case"VIEW":_r(r,2)&&(Tr(r.args[0])&&$r(r.args[0]),kr(r.args[1])&&xr(r.args[1]));break;default:throw new Er(r,"instruction expected")}}return!0}function Cr(r){if(Pr(r))if(Array.isArray(r)||"pair"===r.prim||"or"===r.prim||"option"===r.prim)Ur(r,(r=>Cr(r)));else if(!Object.prototype.hasOwnProperty.call(dr,r.prim))throw new Er(r,`${r.prim}: type is not comparable`);return!0}function Or(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim)||"big_map"===r.prim||"operation"===r.prim||"sapling_state"===r.prim||"ticket"===r.prim)throw new Er(r,`${r.prim}: type can't be used inside PACK/UNPACK instructions`);Ur(r,(r=>Or(r)))}return!0}function xr(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim)||"big_map"===r.prim||"operation"===r.prim||"sapling_state"===r.prim||"ticket"===r.prim||"contract"===r.prim)throw new Er(r,`${r.prim}: type can't be pushed`);Ur(r,(r=>xr(r)))}return!0}function Nr(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim)||"operation"===r.prim||"contract"===r.prim)throw new Er(r,`${r.prim}: type can't be used as part of a storage`);Ur(r,(r=>Nr(r)))}return!0}function Rr(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim)||"operation"===r.prim)throw new Er(r,`${r.prim}: type can't be used as part of a parameter`);Ur(r,(r=>Rr(r)))}return!0}function Lr(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim)||"big_map"===r.prim||"operation"===r.prim||"sapling_state"===r.prim)throw new Er(r,`${r.prim}: type can't be used inside a big_map`);Ur(r,(r=>Lr(r)))}return!0}const Dr=new RegExp("^[a-zA-Z0-9_.%@]*$");function $r(r){if(r.string.length>31)throw new Er(r,`view name too long: ${r.string}`);if(!Dr.test(r.string))throw new Er(r,`invalid character(s) in view name: ${r.string}`)}function kr(r){if(Pr(r)&&br(r)){if(!Object.prototype.hasOwnProperty.call(wr,r.prim))throw new Er(r,"type expected");Ur(r,(r=>kr(r)))}return!0}function Ur(r,t){if(Array.isArray(r)||"pair"===r.prim){const e=Array.isArray(r)?r:r.args;if(void 0===e||e.length<2)throw new Er(r,"at least 2 arguments expected");return e.forEach((r=>{Pr(r)&&t(r)})),!0}switch(r.prim){case"option":case"list":_r(r,1)&&Pr(r.args[0])&&t(r.args[0]);break;case"contract":_r(r,1)&&Rr(r.args[0]);break;case"or":_r(r,2)&&Pr(r.args[0])&&Pr(r.args[1])&&(t(r.args[0]),t(r.args[1]));break;case"lambda":_r(r,2)&&(kr(r.args[0]),kr(r.args[1]));break;case"set":_r(r,1)&&Cr(r.args[0]);break;case"map":_r(r,2)&&Pr(r.args[0])&&Pr(r.args[1])&&(Cr(r.args[0]),t(r.args[1]));break;case"big_map":_r(r,2)&&Pr(r.args[0])&&Pr(r.args[1])&&(Cr(r.args[0]),Lr(r.args[1]),t(r.args[1]));break;case"ticket":_r(r,1)&&Pr(r.args[0])&&Cr(r.args[0]);break;case"sapling_state":case"sapling_transaction":_r(r,1)&&Sr(r.args[0]);break;default:_r(r,0)}return!0}function Fr(r){if("int"in r||"string"in r||"bytes"in r)return!0;if(Array.isArray(r)){let t=0;for(const e of r)br(e)&&"Elt"===e.prim?(_r(e,2)&&(Fr(e.args[0]),Fr(e.args[1])),t++):Fr(e);if(0!==t&&t!==r.length)throw new Er(r,"data entries and map elements can't be intermixed");return!0}if(!br(r))throw new Er(r,"data entry expected");switch(r.prim){case"Unit":case"True":case"False":case"None":_r(r,0);break;case"Pair":if(void 0===r.args||r.args.length<2)throw new Er(r,"at least 2 arguments expected");for(const t of r.args)Fr(t);break;case"Left":case"Right":case"Some":_r(r,1)&&Fr(r.args[0]);break;default:if(!Object.prototype.hasOwnProperty.call(hr,r.prim))throw new Er(r,"data entry or instruction expected");Ir(r)}return!0}function Mr(r){if(Ar(r)){const t={},e={};for(const n of r)if(vr(n)){if("view"!==n.prim){if(n.prim in t)throw new Er(r,`duplicate contract section: ${n.prim}`);t[n.prim]=!0}switch(n.prim){case"code":_r(n,1)&&Ar(n.args[0])&&Ir(n.args[0]);break;case"parameter":if(_r(n,1)&&Rr(n.args[0]),n.annots)throw new Er(n,"Annotation must be part of the parameter type");break;case"storage":_r(n,1)&&Nr(n.args[0]);break;case"view":if(_r(n,4)){if(Tr(n.args[0])){const t=n.args[0];if(t.string in e)throw new Er(r,`duplicate view name: ${t.string}`);e[t.string]=!0,$r(t)}xr(n.args[1]),xr(n.args[2]),Ar(n.args[3])&&Ir(n.args[3])}break;default:throw new Er(r,`unexpected contract section: ${n.prim}`)}}}return!0}function Kr(r){return Object.prototype.hasOwnProperty.call(hr,r.prim)}function Hr(r){if(!Array.isArray(r))return!1;for(const t of r)if("prim"in t){if(Kr(t))throw new X(r,`Instruction outside of a lambda: ${JSON.stringify(r)}`);if("Elt"===t.prim)throw new X(r,`Elt item outside of a map literal: ${JSON.stringify(r)}`)}return!0}const Gr=["parameter","storage","code","False","Elt","Left","None","Pair","Right","Some","True","Unit","PACK","UNPACK","BLAKE2B","SHA256","SHA512","ABS","ADD","AMOUNT","AND","BALANCE","CAR","CDR","CHECK_SIGNATURE","COMPARE","CONCAT","CONS","CREATE_ACCOUNT","CREATE_CONTRACT","IMPLICIT_ACCOUNT","DIP","DROP","DUP","EDIV","EMPTY_MAP","EMPTY_SET","EQ","EXEC","FAILWITH","GE","GET","GT","HASH_KEY","IF","IF_CONS","IF_LEFT","IF_NONE","INT","LAMBDA","LE","LEFT","LOOP","LSL","LSR","LT","MAP","MEM","MUL","NEG","NEQ","NIL","NONE","NOT","NOW","OR","PAIR","PUSH","RIGHT","SIZE","SOME","SOURCE","SENDER","SELF","STEPS_TO_QUOTA","SUB","SWAP","TRANSFER_TOKENS","SET_DELEGATE","UNIT","UPDATE","XOR","ITER","LOOP_LEFT","ADDRESS","CONTRACT","ISNAT","CAST","RENAME","bool","contract","int","key","key_hash","lambda","list","map","big_map","nat","option","or","pair","set","signature","string","bytes","mutez","timestamp","unit","operation","address","SLICE","DIG","DUG","EMPTY_BIG_MAP","APPLY","chain_id","CHAIN_ID","LEVEL","SELF_ADDRESS","never","NEVER","UNPAIR","VOTING_POWER","TOTAL_VOTING_POWER","KECCAK","SHA3","PAIRING_CHECK","bls12_381_g1","bls12_381_g2","bls12_381_fr","sapling_state","sapling_transaction","SAPLING_EMPTY_STATE","SAPLING_VERIFY_UPDATE","ticket","TICKET","READ_TICKET","SPLIT_TICKET","JOIN_TICKETS","GET_AND_UPDATE","chest","chest_key","OPEN_CHEST","VIEW","view","constant","SUB_MUTEZ"];Object.assign({},...Gr.map(((r,t)=>({[r]:t}))));var jr;!function(r){r[r.Int=0]="Int",r[r.String=1]="String",r[r.Sequence=2]="Sequence",r[r.Prim0=3]="Prim0",r[r.Prim0Annot=4]="Prim0Annot",r[r.Prim1=5]="Prim1",r[r.Prim1Annot=6]="Prim1Annot",r[r.Prim2=7]="Prim2",r[r.Prim2Annot=8]="Prim2Annot",r[r.Prim=9]="Prim",r[r.Bytes=10]="Bytes"}(jr||(jr={}));const Yr=new Error("bounds out of range");class Br{constructor(r,t=0,e=r.length){this.buffer=r,this.idx=t,this.cap=e}get length(){return this.cap-this.idx}readBytes(r){if(this.cap-this.idx<r)throw Yr;const t=this.buffer.slice(this.idx,this.idx+r);return this.idx+=r,t}reader(r){if(this.cap-this.idx<r)throw Yr;const t=new Br(this.buffer,this.idx,this.idx+r);return this.idx+=r,t}copy(){return new Br(this.buffer,this.idx,this.cap)}readUint8(){if(this.cap-this.idx<1)throw Yr;return this.buffer[this.idx++]>>>0}readUint16(){if(this.cap-this.idx<2)throw Yr;return(this.buffer[this.idx++]<<8|this.buffer[this.idx++])>>>0}readUint32(){if(this.cap-this.idx<4)throw Yr;return(this.buffer[this.idx++]<<24|this.buffer[this.idx++]<<16|this.buffer[this.idx++]<<8|this.buffer[this.idx++])>>>0}readInt8(){if(this.cap-this.idx<1)throw Yr;return this.buffer[this.idx++]<<24>>24}readInt16(){if(this.cap-this.idx<2)throw Yr;return(this.buffer[this.idx++]<<8|this.buffer[this.idx++])<<16>>16}readInt32(){if(this.cap-this.idx<4)throw Yr;return this.buffer[this.idx++]<<24|this.buffer[this.idx++]<<16|this.buffer[this.idx++]<<8|this.buffer[this.idx++]}}var Jr,zr,Vr;function Wr(r){let t;const e=r.readUint8();switch(e){case zr.ED25519:t="ED25519PublicKeyHash";break;case zr.SECP256K1:t="SECP256K1PublicKeyHash";break;case zr.P256:t="P256PublicKeyHash";break;default:throw new Error(`unknown public key hash tag: ${e}`)}return{type:t,hash:r.readBytes(20)}}function Qr(r){let t;const e=r.readUint8();switch(e){case Jr.Implicit:t=Wr(r);break;case Jr.Originated:t={type:"ContractHash",hash:r.readBytes(20)},r.readBytes(1);break;default:throw new Error(`unknown address tag: ${e}`)}if(0!==r.length){const e=new TextDecoder;t.entryPoint=e.decode(new Uint8Array(r.readBytes(r.length)))}return t}function qr(r){let t,e;const n=r.readUint8();switch(n){case Vr.ED25519:e="ED25519PublicKey",t=32;break;case Vr.SECP256K1:e="SECP256K1PublicKey",t=33;break;case Vr.P256:e="P256PublicKey",t=33;break;default:throw new Error(`unknown public key tag: ${n}`)}return{type:e,publicKey:r.readBytes(t)}}!function(r){r[r.Implicit=0]="Implicit",r[r.Originated=1]="Originated"}(Jr||(Jr={})),function(r){r[r.ED25519=0]="ED25519",r[r.SECP256K1=1]="SECP256K1",r[r.P256=2]="P256"}(zr||(zr={})),function(r){r[r.ED25519=0]="ED25519",r[r.SECP256K1=1]="SECP256K1",r[r.P256=2]="P256"}(Vr||(Vr={}));class Zr extends X{constructor(r,t,e){super(r,e),this.stackState=t,Object.setPrototypeOf(this,Zr.prototype)}}function Xr(r){return Array.isArray(r)?"pair":r.prim}function rt(r){return"prim"in r?r.args:r}function tt(r,t,e=!1){if(Xr(r)!==Xr(t))throw new rr(r,void 0,`types mismatch: ${Xr(r)} != ${Xr(t)}`);const n=[ar(r),ar(t)];if(n[0].t&&n[1].t&&n[0].t[0]!==n[1].t[0])throw new rr(r,void 0,`${Xr(r)}: type names mismatch: ${n[0].t[0]} != ${n[1].t[0]}`);if(e&&n[0].f&&n[1].f&&n[0].f[0]!==n[1].f[0])throw new rr(r,void 0,`${Xr(r)}: field names mismatch: ${n[0].f[0]} != ${n[1].f}`);if(lr(r)){const e=pr("pair",r),n=pr("pair",t);return tt(e.args[0],n.args[0],!0),void tt(e.args[1],n.args[1],!0)}switch(r.prim){case"option":case"list":case"contract":case"set":case"ticket":tt(r.args[0],t.args[0]);break;case"or":tt(r.args[0],t.args[0],!0),tt(r.args[1],t.args[1],!0);break;case"lambda":case"map":case"big_map":tt(r.args[0],t.args[0]),tt(r.args[1],t.args[1]);break;case"sapling_state":case"sapling_transaction":if(parseInt(r.args[0].int,10)!==parseInt(t.args[0].int,10))throw new rr(r,void 0,`${Xr(r)}: type argument mismatch: ${r.args[0].int} != ${t.args[0].int}`)}}function et(r,t){if(r.length!==t.length)throw new rr(r,void 0,`stack length mismatch: ${r.length} != ${t.length}`);for(let e=0;e<r.length;e++)tt(r[e],t[e])}function nt(r,t=!1){var e,n,i;if(!Array.isArray(r)){const s=ar(r);if(((null===(e=s.t)||void 0===e?void 0:e.length)||0)>1)throw new rr(r,void 0,`${r.prim}: at most one type annotation allowed: ${r.annots}`);if(t){if(((null===(n=s.f)||void 0===n?void 0:n.length)||0)>1)throw new rr(r,void 0,`${r.prim}: at most one field annotation allowed: ${r.annots}`)}else if(((null===(i=s.f)||void 0===i?void 0:i.length)||0)>0)throw new rr(r,void 0,`${r.prim}: field annotations aren't allowed: ${r.annots}`)}if(lr(r)){const t=rt(r);for(const r of t)nt(r,!0)}else switch(r.prim){case"option":case"list":case"contract":case"set":nt(r.args[0]);break;case"or":for(const t of r.args)nt(t,!0);break;case"lambda":case"map":case"big_map":nt(r.args[0]),nt(r.args[1])}}function it(r){if(!Array.isArray(r))return!1;for(const t of r)if(!(Array.isArray(t)&&it(t)||"prim"in t&&Kr(t)))return!1;return!0}function st(r,t,e){if(lr(t)){if(ur(r)){Hr(r);const n=pr("Pair",r),i=pr("pair",t);return st(n.args[0],i.args[0],e),void st(n.args[1],i.args[1],e)}throw new rr(t,r,`pair expected: ${JSON.stringify(r)}`)}switch(t.prim){case"int":if("int"in r&&nr(r.int))return;throw new rr(t,r,`integer value expected: ${JSON.stringify(r)}`);case"nat":case"mutez":if("int"in r&&ir(r.int))return;throw new rr(t,r,`natural value expected: ${JSON.stringify(r)}`);case"string":if("string"in r)return;throw new rr(t,r,`string value expected: ${JSON.stringify(r)}`);case"bytes":case"bls12_381_g1":case"bls12_381_g2":if("bytes"in r&&null!==er(r.bytes))return;throw new rr(t,r,`bytes value expected: ${JSON.stringify(r)}`);case"bool":if("prim"in r&&("True"===r.prim||"False"===r.prim))return;throw new rr(t,r,`boolean value expected: ${JSON.stringify(r)}`);case"key_hash":if("string"in r&&null!==cr(r.string,"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash"))return;if("bytes"in r)try{return void function(r){const t=er(r.bytes);if(null===t)throw new Error(`can't parse bytes: "${r.bytes}"`);Wr(new Br(new Uint8Array(t)))}(r)}catch(n){}throw new rr(t,r,`key hash expected: ${JSON.stringify(r)}`);case"timestamp":if(("string"in r||"int"in r)&&null!==fr(r))return;throw new rr(t,r,`timestamp expected: ${JSON.stringify(r)}`);case"address":if("string"in r){let t=r.string;const e=r.string.indexOf("%");if(e>=0&&(t=r.string.slice(0,e)),null!==cr(t,"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash","ContractHash","TxRollupL2Address","RollupAddress"))return}else if("bytes"in r)try{return void function(r){const t=er(r.bytes);if(null===t)throw new Error(`can't parse bytes: "${r.bytes}"`);Qr(new Br(new Uint8Array(t)))}(r)}catch(n){}throw new rr(t,r,`address expected: ${JSON.stringify(r)}`);case"key":if("string"in r&&null!==cr(r.string,"ED25519PublicKey","SECP256K1PublicKey","P256PublicKey"))return;if("bytes"in r)try{return void function(r){const t=er(r.bytes);if(null===t)throw new Error(`can't parse bytes: "${r.bytes}"`);qr(new Br(new Uint8Array(t)))}(r)}catch(n){}throw new rr(t,r,`public key expected: ${JSON.stringify(r)}`);case"unit":if("prim"in r&&"Unit"===r.prim)return;throw new rr(t,r,`unit value expected: ${JSON.stringify(r)}`);case"signature":if("bytes"in r||"string"in r&&null!==cr(r.string,"ED25519Signature","SECP256K1Signature","P256Signature","GenericSignature"))return;throw new rr(t,r,`signature expected: ${JSON.stringify(r)}`);case"chain_id":if("bytes"in r||"string"in r){if(null!==("string"in r?z(r.string):er(r.bytes)))return}throw new rr(t,r,`chain id expected: ${JSON.stringify(r)}`);case"option":if("prim"in r){if("None"===r.prim)return;if("Some"===r.prim)return void st(r.args[0],t.args[0],e)}throw new rr(t,r,`option expected: ${JSON.stringify(r)}`);case"list":case"set":if(Hr(r)){for(const n of r)st(n,t.args[0],e);return}throw new rr(t,r,`${t.prim} expected: ${JSON.stringify(r)}`);case"or":if("prim"in r){if("Left"===r.prim)return void st(r.args[0],t.args[0],e);if("Right"===r.prim)return void st(r.args[0],t.args[1],e)}throw new rr(t,r,`union (or) expected: ${JSON.stringify(r)}`);case"lambda":if(it(r)){const n=at(r,[t.args[0]],e);if("failed"in n)throw new rr(t,r,`function is failed with error type: ${n.failed}`);if(1!==n.length)throw new rr(t,r,"function must return a value");return void tt(t.args[1],n[0])}throw new rr(t,r,`function expected: ${JSON.stringify(r)}`);case"map":case"big_map":if(Array.isArray(r)){for(const n of r){if(!("prim"in n)||"Elt"!==n.prim)throw new rr(t,r,`map elements expected: ${JSON.stringify(r)}`);st(n.args[0],t.args[0],e),st(n.args[1],t.args[1],e)}return}throw new rr(t,r,`${t.prim} expected: ${JSON.stringify(r)}`);case"bls12_381_fr":if("int"in r&&nr(r.int)||"bytes"in r&&null!==er(r.bytes))return;throw new rr(t,r,`BLS12-381 element expected: ${JSON.stringify(r)}`);case"sapling_state":if(Array.isArray(r))return;throw new rr(t,r,`sapling state expected: ${JSON.stringify(r)}`);case"ticket":return void st(r,{prim:"pair",args:[{prim:"address"},t.args[0],{prim:"nat"}]},e);default:throw new rr(t,r,`type ${Xr(t)} don't have Michelson literal representation`)}}function at(r,t,e){const n=(null===e||void 0===e?void 0:e.protocol)||m;if(Array.isArray(r))return function(r,t,e){let n=t,i=t,s=0;for(const a of r){const r=at(a,i,e);if(n=r,"failed"in r)break;i=r,s++}if("failed"in n&&0==n.level&&(!("prim"in n.failed)||"never"!==n.failed.prim)&&s!==r.length-1)throw new Zr(r,n,"FAIL must appear in a tail position");if(void 0!==(null===e||void 0===e?void 0:e.traceCallback)){const i={op:r,in:t,out:n};e.traceCallback(i)}return"failed"in n?{failed:n.failed,level:n.level+1}:n}(r,t,e);const i=r;function s(r,...e){if(t.length<e.length+r)throw new Zr(i,t,`${i.prim}: stack must have at least ${e.length} element(s)`);let n=r;for(const s of e){if(null!==s&&0!==s.length){let r=0;for(;r<s.length&&s[r]!==Xr(t[n]);)r++;if(r===s.length)throw new Zr(i,t,`${i.prim}: stack type mismatch: [${n}] expected to be ${s}, got ${Xr(t[n])} instead`)}n++}return t.slice(r,e.length+r)}function a(r){return(...e)=>{try{return r(...e)}catch(n){throw n instanceof X?new Zr(i,t,n.message):n}}}function o(r){return e=>{try{return r(e)}catch(n){throw n instanceof X?new Zr(i,t,n.message):n}}}const c=a(ar),p=a(et),l=a(tt),u=o(Cr),h=o(Or),w=o(Nr),E=o(xr),b=o(Lr);function v(r,e){const n=c(i,Object.assign(Object.assign({},e),{emptyFields:void 0!==r.f&&r.f>1,emptyVar:void 0!==r.v&&r.v>1})),s=(r,e,n)=>{if(r&&r.length>(e||0))throw new Zr(i,t,`${i.prim}: at most ${e||0} ${n} annotations allowed`)};return s(n.f,r.f,"field"),s(n.t,r.t,"type"),s(n.v,r.v,"variable"),n}function A(r,t){const e=r,n=Array.isArray(e)?{prim:"pair",args:e}:e,i=c(n),s=void 0!==t.v||void 0!==t.t||void 0!==t.f?[...(null===t.v?i.v:t.v)||[],...(null===t.t?i.t:t.t)||[],...(null===t.f?i.f:t.f)||[]]:void 0,a=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(null!=r&&"function"===typeof Object.getOwnPropertySymbols){var i=0;for(n=Object.getOwnPropertySymbols(r);i<n.length;i++)t.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(r,n[i])&&(e[n[i]]=r[n[i]])}return e}(n,["annots"]);return Object.assign(Object.assign({},a),s&&0!==s.length&&{annots:s})}function P(r,t){const e=v({v:1});return A(r,{v:void 0!==e.v?e.v:void 0!==t?[t]:null,t:null})}function y(r,e,n,s,a){var o,p,l,u;const g=null===(o=c(e).f)||void 0===o?void 0:o[0],f=null===(p=n.f)||void 0===p?void 0:p[s];if(void 0!==f&&"%"!==f&&void 0!==g&&f!==g)throw new Zr(i,t,`${i.prim}: field names doesn't match: ${f} !== ${g}`);const m=null===(l=n.v)||void 0===l?void 0:l[s],h=null===(u=c(r).v)||void 0===u?void 0:u[0];return A(e,{t:null,v:m?"@%"===m?g?["@"+g.slice(1)]:void 0:"@%%"===m?h?["@"+h.slice(1)+"."+(g?g.slice(1):a)]:g?["@"+g.slice(1)]:void 0:[m]:null})}function S(r,e,n=e){const s=pr("pair",r);if(1===n)return[s.args[0]];if(2===n)return s.args;const a=s.args[1];if(lr(a))return[s.args[0],...S(a,e,n-1)];throw new Zr(i,t,`${i.prim}: at least ${e} fields are expected`)}function T(r,e,n=e){if(0===n)return r;const s=pr("pair",r);if(1===n)return s.args[0];const a=s.args[1];if(lr(a))return T(a,e,n-2);if(2===n)return a;throw new Zr(i,t,`${i.prim}: at least ${e+1} fields are expected`)}function _(r,e,n,s=n){if(0===s)return e;const a=pr("pair",r);if(1===s)return Object.assign(Object.assign({},a),{args:[e,a.args[1]]});const o=a.args[1];if(lr(o))return Object.assign(Object.assign({},a),{args:[a.args[0],_(o,e,n,s-2)]});if(2===s)return Object.assign(Object.assign({},a),{args:[a.args[0],e]});throw new Zr(i,t,`${i.prim}: at least ${n+1} fields are expected`)}const I=(r,t)=>["@"+(r.v?r.v[0].slice(1)+".":"")+t];function C(r,t){return"failed"in r||"failed"in t?"failed"in r?t:r:(p(r,t),r)}const O=(r=>{var i,a,o,m,O;switch(r.prim){case"DUP":{const e=r.args?parseInt(r.args[0].int,10):1;if(0===e)throw new Zr(r,t,"DUP 0 is forbidden");const n=s(e-1,null)[0];if("ticket"===Xr(n))throw new Zr(r,t,"ticket can't be DUPed");return[n,...t]}case"SWAP":{const r=s(0,null,null);return v({}),[r[1],r[0],...t.slice(2)]}case"SOME":return[A({prim:"option",args:[s(0,null)[0]]},v({t:1,v:1})),...t.slice(1)];case"UNIT":return[A({prim:"unit"},v({v:1,t:1})),...t];case"PAIR":{const e=r.args?parseInt(r.args[0].int,10):2;if(e<2)throw new Zr(r,t,`PAIR ${e} is forbidden`);const n=s(0,...new Array(e).fill(null)),i=v({f:e,t:1,v:1},{specialFields:!0}),a=r=>{const t=r.lastIndexOf(".");return r.slice(t>0?t+1:1)},o=n.map(((r,t)=>{var e;const n=c(r);return A(r,{v:null,t:null,f:i.f&&i.f.length>t&&"%"!==i.f[t]?"%@"===i.f[t]?n.v?["%"+a((null===(e=n.v)||void 0===e?void 0:e[0])||"")]:void 0:[i.f[t]]:void 0})}));return[A({prim:"pair",args:o},{t:i.t,v:i.v}),...t.slice(e)]}case"UNPAIR":{const e=r.args?parseInt(r.args[0].int,10):2;if(e<2)throw new Zr(r,t,`UNPAIR ${e} is forbidden`);const n=s(0,["pair"])[0],i=v({f:2,v:2},{specialVar:!0});return[...S(n,e).map(((r,t)=>y(n,r,i,t,0===t?"car":"cdr"))),...t.slice(1)]}case"CAR":case"CDR":{const e=pr("pair",s(0,["pair"])[0]);return[y(e,e.args["CAR"===r.prim?0:1],v({f:1,v:1},{specialVar:!0}),0,r.prim.toLocaleLowerCase()),...t.slice(1)]}case"CONS":{const r=s(0,null,["list"]);return l(r[0],r[1].args[0]),[P({prim:"list",args:[r[1].args[0]]}),...t.slice(2)]}case"SIZE":return s(0,["string","list","set","map","bytes"]),[P({prim:"nat"}),...t.slice(1)];case"MEM":{const r=s(0,null,["set","map","big_map"]);return u(r[0]),l(r[0],r[1].args[0]),[P({prim:"bool"}),...t.slice(2)]}case"GET":if(r.args){const e=parseInt(r.args[0].int,10);return[P(T(s(0,["pair"])[0],e)),...t.slice(1)]}{const r=s(0,null,["map","big_map"]);return u(r[0]),l(r[0],r[1].args[0]),[P({prim:"option",args:[r[1].args[1]]}),...t.slice(2)]}case"UPDATE":if(r.args){const e=parseInt(r.args[0].int,10),n=s(0,null,["pair"]);return[P(_(n[1],n[0],e)),...t.slice(2)]}{const r=s(0,null,["bool","option"]);if(u(r[0]),"bool"===r[1].prim){const e=s(2,["set"]);return l(r[0],e[0].args[0]),[P({prim:"set",args:[A(r[0],{t:null})]}),...t.slice(3)]}const e=s(2,["map","big_map"]);return l(r[0],e[0].args[0]),"map"===e[0].prim?[P({prim:"map",args:[A(r[0],{t:null}),A(r[1].args[0],{t:null})]}),...t.slice(3)]:(b(r[1].args[0]),[P({prim:"big_map",args:[A(r[0],{t:null}),A(r[1].args[0],{t:null})]}),...t.slice(3)])}case"GET_AND_UPDATE":{const r=v({v:2}),e=s(0,null,["option"],["map","big_map"]);u(e[0]),l(e[0],e[2].args[0]),l(e[1].args[0],e[2].args[1]);const n=null===(i=r.v)||void 0===i?void 0:i.map((r=>"@"!==r?[r]:void 0));return"map"===e[2].prim?[A({prim:"option",args:[e[2].args[1]]},{v:null===n||void 0===n?void 0:n[0]}),A({prim:"map",args:[A(e[0],{t:null}),A(e[1].args[0],{t:null})]},{v:null===n||void 0===n?void 0:n[1]}),...t.slice(3)]:(b(e[1].args[0]),[A({prim:"option",args:[e[2].args[1]]},{v:null===n||void 0===n?void 0:n[0]}),A({prim:"big_map",args:[A(e[0],{t:null}),A(e[1].args[0],{t:null})]},{v:null===n||void 0===n?void 0:n[1]}),...t.slice(3)])}case"EXEC":{const r=s(0,null,["lambda"]);return l(r[0],r[1].args[0]),[P(r[1].args[1]),...t.slice(2)]}case"APPLY":{const e=s(0,null,["lambda"]);if(w(e[0]),E(e[0]),!lr(e[1].args[0]))throw new Zr(r,t,`${r.prim}: function's argument must be a pair: ${Xr(e[1].args[0])}`);const n=e[1].args[0];return l(e[0],rt(n)[0]),[P({prim:"lambda",args:[rt(n)[1],e[1].args[1]]}),...t.slice(2)]}case"FAILWITH":{const r=s(0,null)[0];return d(n,f.PtEdo2Zk)||h(r),{failed:r,level:0}}case"NEVER":return s(0,["never"]),{failed:{prim:"never"},level:0};case"RENAME":return[P(s(0,null)[0]),...t.slice(1)];case"CONCAT":{const e=s(0,["string","list","bytes"]);if("list"===e[0].prim){if("string"!==Xr(e[0].args[0])&&"bytes"!==Xr(e[0].args[0]))throw new Zr(r,t,`${r.prim}: can't concatenate list of ${Xr(e[0].args[0])}'s`);return[P(e[0].args[0]),...t.slice(1)]}const n=s(1,["string","bytes"]);if(e[0].prim!==n[0].prim)throw new Zr(r,t,`${r.prim}: can't concatenate ${e[0].prim} with ${n[0].prim}`);return[P(n[0]),...t.slice(2)]}case"SLICE":return[P({prim:"option",args:[s(0,["nat"],["nat"],["string","bytes"])[2]]},"@slice"),...t.slice(3)];case"PACK":{const r=s(0,null)[0];return h(r),[P({prim:"bytes"},"@packed"),...t.slice(1)]}case"ADD":{const e=s(0,["nat","int","timestamp","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"],["nat","int","timestamp","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"]);if("nat"===e[0].prim&&"int"===e[1].prim||"int"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"int"}),...t.slice(2)];if("int"===e[0].prim&&"timestamp"===e[1].prim||"timestamp"===e[0].prim&&"int"===e[1].prim)return[P({prim:"timestamp"}),...t.slice(2)];if(("int"===e[0].prim||"nat"===e[0].prim||"mutez"===e[0].prim||"bls12_381_g1"===e[0].prim||"bls12_381_g2"===e[0].prim||"bls12_381_fr"===e[0].prim)&&e[0].prim===e[1].prim)return[P(e[0]),...t.slice(2)];throw new Zr(r,t,`${r.prim}: can't add ${e[0].prim} to ${e[1].prim}`)}case"SUB":{const e=d(n,f.PsiThaCa)?s(0,["nat","int","timestamp","mutez"],["nat","int","timestamp","mutez"]):s(0,["nat","int","timestamp"],["nat","int","timestamp"]);if(("nat"===e[0].prim||"int"===e[0].prim)&&("nat"===e[1].prim||"int"===e[1].prim)||"timestamp"===e[0].prim&&"timestamp"===e[1].prim)return[P({prim:"int"}),...t.slice(2)];if("timestamp"===e[0].prim&&"int"===e[1].prim)return[P({prim:"timestamp"}),...t.slice(2)];if("mutez"===e[0].prim&&"mutez"===e[1].prim)return[P({prim:"mutez"}),...t.slice(2)];throw new Zr(r,t,`${r.prim}: can't subtract ${e[0].prim} from ${e[1].prim}`)}case"SUB_MUTEZ":return s(0,["mutez"],["mutez"]),[P({prim:"option",args:[{prim:"mutez"}]}),...t.slice(2)];case"MUL":{const e=s(0,["nat","int","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"],["nat","int","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"]);if("nat"===e[0].prim&&"int"===e[1].prim||"int"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"int"}),...t.slice(2)];if("nat"===e[0].prim&&"mutez"===e[1].prim||"mutez"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"mutez"}),...t.slice(2)];if(("bls12_381_g1"===e[0].prim||"bls12_381_g2"===e[0].prim||"bls12_381_fr"===e[0].prim)&&"bls12_381_fr"===e[1].prim||("nat"===e[0].prim||"int"===e[0].prim)&&e[0].prim===e[1].prim)return[P(e[0]),...t.slice(2)];if(("nat"===e[0].prim||"int"===e[0].prim)&&"bls12_381_fr"===e[1].prim||("nat"===e[1].prim||"int"===e[1].prim)&&"bls12_381_fr"===e[0].prim)return[P({prim:"bls12_381_fr"}),...t.slice(2)];throw new Zr(r,t,`${r.prim}: can't multiply ${e[0].prim} by ${e[1].prim}`)}case"EDIV":{const e=(r,t)=>({prim:"option",args:[{prim:"pair",args:[{prim:r},{prim:t}]}]}),n=s(0,["nat","int","mutez"],["nat","int","mutez"]);if("nat"===n[0].prim&&"nat"===n[1].prim)return[P(e("nat","nat")),...t.slice(2)];if(!("nat"!==n[0].prim&&"int"!==n[0].prim||"nat"!==n[1].prim&&"int"!==n[1].prim))return[P(e("int","nat")),...t.slice(2)];if("mutez"===n[0].prim&&"nat"===n[1].prim)return[P(e("mutez","mutez")),...t.slice(2)];if("mutez"===n[0].prim&&"mutez"===n[1].prim)return[P(e("nat","mutez")),...t.slice(2)];throw new Zr(r,t,`${r.prim}: can't euclideally divide ${n[0].prim} by ${n[1].prim}`)}case"ABS":return s(0,["int"]),[P({prim:"nat"}),...t.slice(1)];case"ISNAT":return s(0,["int"]),[P({prim:"option",args:[{prim:"nat"}]}),...t.slice(1)];case"INT":return s(0,["nat","bls12_381_fr"]),[P({prim:"int"}),...t.slice(1)];case"NEG":{const r=s(0,["nat","int","bls12_381_g1","bls12_381_g2","bls12_381_fr"])[0];return"nat"===r.prim||"int"===r.prim?[P({prim:"int"}),...t.slice(1)]:[P(r),...t.slice(1)]}case"LSL":case"LSR":return s(0,["nat"],["nat"]),[P({prim:"nat"}),...t.slice(2)];case"OR":case"XOR":{const e=s(0,["nat","bool"],["nat","bool"]);if(e[0].prim!==e[1].prim)throw new Zr(r,t,`${r.prim}: both arguments must be of the same type: ${e[0].prim}, ${e[1].prim}`);return[P(e[1]),...t.slice(2)]}case"AND":{const e=s(0,["nat","bool","int"],["nat","bool"]);if(("int"!==e[0].prim||"nat"!==e[1].prim)&&e[0].prim!==e[1].prim)throw new Zr(r,t,`${r.prim}: both arguments must be of the same type: ${e[0].prim}, ${e[1].prim}`);return[P(e[1]),...t.slice(2)]}case"NOT":return"bool"===s(0,["nat","bool","int"])[0].prim?[P({prim:"bool"}),...t.slice(1)]:[P({prim:"int"}),...t.slice(1)];case"COMPARE":{const r=s(0,null,null);return u(r[0]),u(r[1]),[P({prim:"int"}),...t.slice(2)]}case"EQ":case"NEQ":case"LT":case"GT":case"LE":case"GE":return s(0,["int"]),[P({prim:"bool"}),...t.slice(1)];case"SELF":{if(void 0===(null===e||void 0===e?void 0:e.contract))throw new Zr(r,t,`${r.prim}: contract required`);const n=v({f:1,v:1}),i=pt(e.contract,null===(a=n.f)||void 0===a?void 0:a[0]);if(null===i)throw new Zr(r,t,`${r.prim}: contract has no entrypoint ${i}`);return[A({prim:"contract",args:[i]},{v:n.v?n.v:["@self"]}),...t]}case"TRANSFER_TOKENS":{const r=s(0,null,["mutez"],["contract"]);return l(r[0],r[2].args[0]),[P({prim:"operation"}),...t.slice(3)]}case"SET_DELEGATE":{const e=s(0,["option"])[0];if("key_hash"!==Xr(e.args[0]))throw new Zr(r,t,`${r.prim}: key hash expected: ${Xr(e.args[0])}`);return[P({prim:"operation"}),...t.slice(1)]}case"IMPLICIT_ACCOUNT":return s(0,["key_hash"]),[P({prim:"contract",args:[{prim:"unit"}]}),...t.slice(1)];case"NOW":return[P({prim:"timestamp"},"@now"),...t];case"AMOUNT":return[P({prim:"mutez"},"@amount"),...t];case"BALANCE":return[P({prim:"mutez"},"@balance"),...t];case"CHECK_SIGNATURE":return s(0,["key"],["signature"],["bytes"]),[P({prim:"bool"}),...t.slice(3)];case"BLAKE2B":case"SHA256":case"SHA512":case"KECCAK":case"SHA3":return s(0,["bytes"]),[P({prim:"bytes"}),...t.slice(1)];case"HASH_KEY":return s(0,["key"]),[P({prim:"key_hash"}),...t.slice(1)];case"SOURCE":return[P({prim:"address"},"@source"),...t];case"SENDER":return[P({prim:"address"},"@sender"),...t];case"ADDRESS":{const r=s(0,["contract"])[0],e=v({v:1});return[A({prim:"address",[g]:r},{v:e.v?e.v:I(c(r),"address")}),...t.slice(1)]}case"SELF_ADDRESS":{const r={prim:"address"};return void 0!==(null===e||void 0===e?void 0:e.contract)&&(r[g]={prim:"contract",args:[ot(e.contract,"parameter").args[0]]}),[P(r,"@address"),...t]}case"CHAIN_ID":return[P({prim:"chain_id"}),...t];case"DROP":{v({});const e=void 0!==r.args?parseInt(r.args[0].int,10):1;return s(e-1,null),t.slice(e)}case"DIG":{v({});const e=parseInt(r.args[0].int,10);return[s(e,null)[0],...t.slice(0,e),...t.slice(e+1)]}case"DUG":{v({});const e=parseInt(r.args[0].int,10);return[...t.slice(1,e+1),s(0,null)[0],...t.slice(e+1)]}case"NONE":return nt(r.args[0]),[A({prim:"option",args:[r.args[0]]},v({t:1,v:1})),...t];case"LEFT":case"RIGHT":{const e=s(0,null)[0],n=v({f:2,t:1,v:1},{specialFields:!0}),i=c(e),a=[A(e,{t:null,v:null,f:n.f&&n.f.length>0&&"%"!==n.f[0]?"%@"===n.f[0]?i.v?["%"+i.v[0].slice(1)]:void 0:n.f:void 0}),A(r.args[0],{t:null,f:n.f&&n.f.length>1&&"%"!==n.f[1]?n.f:void 0})];return[A({prim:"or",args:"LEFT"===r.prim?a:[a[1],a[0]]},{t:n.t,v:n.v}),...t.slice(1)]}case"NIL":return nt(r.args[0]),[A({prim:"list",args:[r.args[0]]},v({t:1,v:1})),...t];case"UNPACK":return s(0,["bytes"]),nt(r.args[0]),[P({prim:"option",args:[r.args[0]]},"@unpacked"),...t.slice(1)];case"CONTRACT":{const e=s(0,["address"])[0];nt(r.args[0]);const n=v({v:1,f:1}),i=e[g];if(void 0!==i){const e=pt(i,null===(o=n.f)||void 0===o?void 0:o[0]);if(null===e)throw new Zr(r,t,`${r.prim}: contract has no entrypoint ${e}`);l(e,r.args[0])}return[A({prim:"option",args:[{prim:"contract",args:[r.args[0]]}]},{v:n.v?n.v:I(c(e),"contract")}),...t.slice(1)]}case"CAST":{v({});const e=s(0,null)[0];return nt(r.args[0]),l(r.args[0],e),[r.args[0],...t.slice(1)]}case"IF_NONE":{v({});const n=s(0,["option"])[0],i=t.slice(1);return C(at(r.args[0],i,e),at(r.args[1],[A(n.args[0],{t:null,v:I(c(n),"some")}),...i],e))}case"IF_LEFT":{v({});const n=s(0,["or"])[0],i=c(n),a=c(n.args[0]),o=c(n.args[1]),p=t.slice(1);return C(at(r.args[0],[A(n.args[0],{t:null,v:I(i,a.f?a.f[0].slice(1):"left")}),...p],e),at(r.args[1],[A(n.args[1],{t:null,v:I(i,o.f?o.f[0].slice(1):"right")}),...p],e))}case"IF_CONS":{v({});const n=s(0,["list"])[0],i=c(n),a=t.slice(1);return C(at(r.args[0],[A(n.args[0],{t:null,v:I(i,"hd")}),A(n,{t:null,v:I(i,"tl")}),...a],e),at(r.args[1],a,e))}case"IF":{v({}),s(0,["bool"]);const n=t.slice(1);return C(at(r.args[0],n,e),at(r.args[1],n,e))}case"MAP":{const n=s(0,["list","map","option"])[0],i=t.slice(1),a="map"===n.prim?{prim:"pair",args:n.args}:n.args[0],o=at(r.args[0],[A(a,{t:null,v:I(c(n),"elt")}),...i],e);if("failed"in o){if(!("prim"in o.failed)||"never"!==o.failed.prim)throw new Zr(r,t,`${r.prim}: FAIL is not allowed in MAP`);return{failed:o.failed,level:o.level+1}}if(o.length<1)throw new Zr(r,t,`${r.prim}: function must return a value`);return p(o.slice(1),i),"list"===n.prim?[P({prim:"list",args:[o[0]]}),...i]:"map"===n.prim?[P({prim:"map",args:[n.args[0],o[0]]}),...i]:[P({prim:"option",args:[o[0]]}),...i]}case"ITER":{v({});const n=s(0,["set","list","map"])[0],i=t.slice(1),a="map"===n.prim?{prim:"pair",args:n.args}:n.args[0],o=at(r.args[0],[A(a,{t:null,v:I(c(n),"elt")}),...i],e);return"failed"in o?{failed:o.failed,level:o.level+1}:(p(o,i),i)}case"LOOP":{v({}),s(0,["bool"]);const n=t.slice(1),i=at(r.args[0],n,e);return"failed"in i?{failed:i.failed,level:i.level+1}:(p(i,[{prim:"bool"},...n]),n)}case"LOOP_LEFT":{v({});const n=s(0,["or"])[0],i=t.slice(1),a=at(r.args[0],[A(n.args[0],{t:null,v:I(c(n),"left")}),...i],e);return"failed"in a?{failed:a.failed,level:a.level+1}:(p(a,[n,...i]),[A(n.args[1],{t:null,v:v({v:1}).v}),...i])}case"DIP":{v({});const n=2===r.args.length?parseInt(r.args[0].int,10):1;s(n-1,null);const i=t.slice(0,n),a=t.slice(n),o=2===r.args.length?at(r.args[1],a,e):at(r.args[0],a,e);return"failed"in o?{failed:o.failed,level:o.level+1}:[...i,...o]}case"CREATE_CONTRACT":{const e=v({v:2}),n=s(0,["option"],["mutez"],null);if("key_hash"!==Xr(n[0].args[0]))throw new Zr(r,t,`${r.prim}: key hash expected: ${Xr(n[0].args[0])}`);w(n[2])&&(ut(r.args[0]),tt(ot(r.args[0],"storage").args[0],n[2]));const i=null===(m=e.v)||void 0===m?void 0:m.map((r=>"@"!==r?[r]:void 0));return[A({prim:"operation"},{v:null===i||void 0===i?void 0:i[0]}),A({prim:"address",[g]:{prim:"contract",args:[ot(r.args[0],"parameter").args[0]]}},{v:null===i||void 0===i?void 0:i[1]}),...t.slice(3)]}case"PUSH":return nt(r.args[0]),st(r.args[1],r.args[0],Object.assign(Object.assign({},e),{contract:void 0})),[P(r.args[0]),...t];case"EMPTY_SET":return nt(r.args[0]),u(r.args[0]),[A({prim:"set",args:r.args},v({t:1,v:1})),...t];case"EMPTY_MAP":return nt(r.args[0]),u(r.args[0]),nt(r.args[1]),[A({prim:"map",args:r.args},v({t:1,v:1})),...t];case"EMPTY_BIG_MAP":return nt(r.args[0]),u(r.args[0]),nt(r.args[1]),b(r.args[0]),[A({prim:"big_map",args:r.args},v({t:1,v:1})),...t];case"LAMBDA":{nt(r.args[0]),nt(r.args[1]);const n=at(r.args[2],[r.args[0]],Object.assign(Object.assign({},e),{contract:void 0}));if("failed"in n)return{failed:n.failed,level:n.level+1};if(1!==n.length)throw new Zr(r,t,`${r.prim}: function must return a value`);return l(r.args[1],n[0]),[P({prim:"lambda",args:[r.args[0],r.args[1]]}),...t]}case"LEVEL":return[P({prim:"nat"},"@level"),...t];case"TOTAL_VOTING_POWER":case"MIN_BLOCK_TIME":return[P({prim:"nat"}),...t];case"VOTING_POWER":return s(0,["key_hash"]),[P({prim:"nat"}),...t.slice(1)];case"TICKET":{const r=s(0,null,["nat"])[0];return u(r),[A({prim:"ticket",args:[r]},v({t:1,v:1})),...t.slice(2)]}case"JOIN_TICKETS":{const e=pr("pair",s(0,["pair"])[0]);if("ticket"!==Xr(e.args[0]))throw new Zr(r,t,`${r.prim}: ticket expected: ${Xr(e.args[0])}`);return l(e.args[0],e.args[1]),[P({prim:"option",args:[A(e.args[0],{t:null})]}),...t.slice(1)]}case"SPLIT_TICKET":{const e=s(0,["ticket"],["pair"]),n=pr("pair",e[1]);if("nat"!==Xr(n.args[0]))throw new Zr(r,t,`${r.prim}: nat expected: ${Xr(n.args[0])}`);return l(n.args[0],n.args[1]),[P({prim:"option",args:[{prim:"pair",args:[A(e[0],{t:null}),A(e[0],{t:null})]}]}),...t.slice(2)]}case"READ_TICKET":{const r=v({v:2}),e=s(0,["ticket"])[0],n=null===(O=r.v)||void 0===O?void 0:O.map((r=>"@"!==r?[r]:void 0));return[A({prim:"pair",args:[{prim:"address"},A(e.args[0],{t:null}),{prim:"nat"}]},{v:null===n||void 0===n?void 0:n[0]}),A(e,{v:null===n||void 0===n?void 0:n[1],t:null}),...t.slice(1)]}case"PAIRING_CHECK":{const e=s(0,["list"])[0].args[0];if(!lr(e))throw new Zr(r,t,`${r.prim}: pair expected: ${Xr(e)}`);const n=pr("pair",e);if("bls12_381_g1"!==Xr(n.args[0]))throw new Zr(r,t,`${r.prim}: bls12_381_g1 expected: ${Xr(n.args[0])}`);if("bls12_381_g2"!==Xr(n.args[1]))throw new Zr(r,t,`${r.prim}: bls12_381_g2 expected: ${Xr(n.args[1])}`);return[P({prim:"bool"}),...t.slice(1)]}case"SAPLING_EMPTY_STATE":return[A({prim:"sapling_state",args:[r.args[0]]},v({v:1,t:1})),...t];case"SAPLING_VERIFY_UPDATE":{const e=s(0,["sapling_transaction"],["sapling_state"]);if(parseInt(e[0].args[0].int,10)!==parseInt(e[1].args[0].int,10))throw new Zr(r,t,`${r.prim}: sapling memo size mismatch: ${e[0].args[0].int} != ${e[1].args[0].int}`);return d(n,f.PtJakarta)?[P({prim:"option",args:[{prim:"pair",args:[{prim:"int"},A(e[1],{t:null})]}]}),...t.slice(2)]:[P({prim:"option",args:[{prim:"pair",args:[{prim:"bytes"},{prim:"pair",args:[{prim:"int"},A(e[1],{t:null})]}]}]}),...t.slice(2)]}case"OPEN_CHEST":return s(0,["chest_key"],["chest"],["nat"]),[P({prim:"or",args:[{prim:"bytes"},{prim:"bool"}]}),...t.slice(3)];case"VIEW":{const e=s(0,null,["address"]);return E(e[0]),[P({prim:"option",args:[r.args[1]]}),...t.slice(2)]}default:throw new X(r,`unexpected instruction: ${r.prim}`)}})(i);if(void 0!==(null===e||void 0===e?void 0:e.traceCallback)){const r={op:i,in:t,out:O};e.traceCallback(r)}return O}function ot(r,t){for(const e of r)if(e.prim===t)return e;throw new X(r,`missing contract section: ${t}`)}function ct(r){if(Array.isArray(r))for(const t of r)if("prim"in t&&("parameter"===t.prim||"storage"===t.prim||"code"===t.prim))return!0;return!1}function pt(r,t){t=t||"%default";const e=lt(r).find((r=>r[0]===t));return void 0!==e?e[1]:"%default"===t?ct(r)?ot(r,"parameter").args[0]:r:null}function lt(r){if(ct(r)){const t=ot(r,"parameter"),e=lt(t.args[0]),n=ar(t);return n.f?[[n.f[0],t.args[0]],...e]:e}if(t=r,Array.isArray(t)||"or"===t.prim){const t=rt(r),e=r=>{const e=ar(t[r]);if("or"===Xr(t[r])){const n=lt(t[r]);return e.f?[[e.f[0],t[r]],...n]:n}return e.f?[[e.f[0],t[r]]]:[]};return[...e(0),...e(1)]}var t;return[]}function ut(r,t){const e=(e,n,i,s)=>{nt(e,!0),nt(n);const a=at(s,[{prim:"pair",args:[Object.assign(Object.assign({},e),{annots:["@parameter"]}),Object.assign(Object.assign({},n),{annots:["@storage"]})]}],Object.assign(Object.assign({},t),{contract:r}));if("failed"in a)return a;try{et(a,[i])}catch(o){throw o instanceof X?new Zr(s,a,o.message):o}return a},n=ot(r,"parameter").args[0],i=ot(r,"storage").args[0],s=e(n,i,{prim:"pair",args:[{prim:"list",args:[{prim:"operation"}]},i]},ot(r,"code").args[0]);for(const a of Object.values(function(r){const t={};for(const e of r)"view"===e.prim&&(t[e.args[0].string]=e);return t}(r)))e(a.args[1],i,a.args[2],a.args[3]);return s}function gt(r,t,e){nt(t),st(r,t,e||null)}class ft{constructor(r,t){this.contract=r,this.ctx=Object.assign({contract:r},t),this.output=ut(r,this.ctx)}static parse(r,t){const e=new M(t),n="string"===typeof r?e.parseScript(r):e.parseJSON(r);if(null===n)throw new V("empty contract");if(Mr(n))return new ft(n,t)}static parseTypeExpression(r,t){const e=new M(t),n="string"===typeof r?e.parseScript(r):e.parseJSON(r);if(null===n)throw new W("empty type expression");if(kr(n)&&nt(n))return n;throw void 0}static parseDataExpression(r,t){const e=new M(t),n="string"===typeof r?e.parseScript(r):e.parseJSON(r);if(null===n)throw new Q("empty data expression");if(Fr(n))return n;throw void 0}section(r){return ot(this.contract,r)}entryPoints(){return lt(this.contract)}entryPoint(r){return pt(this.contract,r)}assertDataValid(r,t){gt(r,t,this.ctx)}isDataValid(r,t){return function(r,t,e){try{return gt(r,t,e),!0}catch(n){return!1}}(r,t,this.ctx)}assertParameterValid(r,t){const e=this.entryPoint(r||void 0);if(null===e)throw new q(null===r||void 0===r?void 0:r.toString());this.assertDataValid(t,e)}isParameterValid(r,t){try{return this.assertParameterValid(r,t),!0}catch(e){return!1}}functionType(r,t){return function(r,t,e){for(const n of t)nt(n);if(void 0!==(null===e||void 0===e?void 0:e.contract))for(const n of["parameter","storage"])nt(ot(e.contract,n).args[0]);return at(r,t,e||null)}(r,t,this.ctx)}}new ft([{prim:"parameter",args:[{prim:"unit"}]},{prim:"storage",args:[{prim:"unit"}]},{prim:"code",args:[[{prim:"CAR"},{prim:"NIL",args:[{prim:"operation"}]},{prim:"PAIR"}]]}])}}]);